module Freekick.Libsoccer.MatchCommon
where

import Libaddutil.Vector
import Data.Char
import qualified Data.Map
import Libaddutil.Primitives
import Freekick.Libsoccer.Player
import Freekick.Libsoccer.MatchInfo

data MatchStatus = MatchStatus { players :: Players
                               , home    :: Integer
                               , away    :: Integer
                               , time    :: Time
                               , ball    :: Ball
                               , match   :: BallPlay
                               }
    deriving (Eq, Show, Read)

startMatchStatus :: MatchStatus
startMatchStatus = MatchStatus Data.Map.empty 0 0 nullTime newBall (BallOut PreKickoff)

createMatchStatusFromMatchInfo :: MatchInfo -> MatchStatus
createMatchStatusFromMatchInfo m = MatchStatus (Data.Map.fromList (zip ids playerinfos)) 0 0 (0, 0, 0) newBall (BallOut PreKickoff)
    where ids         = map Freekick.Libsoccer.Player.getID (homepl m ++ awaypl m)
          playerinfos = map createPlayerInfo (homepl m ++ awaypl m)

createPlayerInfo :: Player -> PlayerInfo
createPlayerInfo p = PlayerInfo p (Entity (fromInteger lx, 0, fromInteger lz) (0, 0, 0) (0, 0, 0) )
    where lx = (idnum p) `mod` 521
          lz = (idnum p) `mod` 479

type Players = Data.Map.Map Integer PlayerInfo

data PlayerInfo = PlayerInfo { staticplayer :: Player, plentity :: Entity }
    deriving (Eq, Show, Read)

inputType :: String -> InputType
inputType s | length s < 1 = Invalid
            | otherwise    = if head s == '(' && last s == ')' 
                                 then if isDigit cc
                                          then Update 
                                          else case cc of
                                                 'a' -> Controls Move
                                                 'b' -> Controls Kick
                                                 'c' -> Controls Tackle
                                                 'A' -> Status Pause
                                                 'B' -> Status Time
                                                 'C' -> Status Score
                                                 _   -> Invalid
                                 else Invalid
            where cc = head s

data InputType = Invalid
               | Update 
               | Status StatusType
               | Controls ControlType
     deriving (Show, Eq, Read)

data ControlType = Move
                 | Kick
                 | Tackle
     deriving (Show, Eq, Read)

data StatusType = Pause
                | Time
                | Score
     deriving (Show, Eq, Read)

controlPlayeridToken :: String -> Integer
controlPlayeridToken s = if inputType s == Controls Move then read (last (words s)) else 0

controlMoveCoordinatesToken :: String -> Vector3
controlMoveCoordinatesToken s = if inputType s == Controls Move then (x, y, z) else (0, 0, 0)
    where x = read $ (words s) !! 1
          y = read $ (words s) !! 2
          z = read $ (words s) !! 3

data Ball = Ball { ballentity :: Entity 
                 , weight     :: Float 
                 }
    deriving (Show, Eq, Read)

newBall :: Ball
newBall = Ball nullEntity 0.43

data BallPlay = BallIn
              | BallOut BallOutType
    deriving (Show, Eq, Read)

data BallOutType = PreKickoff
                 | Kickoff
                 | Throwin
                 | Goalkick
                 | Cornerkick
                 | IndirectFreekick
                 | DirectFreekick
                 | PenaltyKick
                 | DroppedBall
                 | HalfFullTime
    deriving (Show, Eq, Read)

events :: String -> [String]
events "" = []
events s = e : (events rest)
    where (e, rest) = span (/= ')') (drop 1 (dropWhile (/= '(') s))

data UpdateType = UpdateLocation
                | UpdateVelocity
                | UpdateAcceleration

applyEventOnPlayer :: String -> PlayerInfo -> PlayerInfo
applyEventOnPlayer s p = case (getUpdateType s) of
                     UpdateLocation     -> setPlayerLocation     (getUpdateCoordinates s) p
                     UpdateVelocity     -> setPlayerVelocity     (getUpdateCoordinates s) p
                     _                  -> setPlayerAcceleration (getUpdateCoordinates s) p

setPlayerLocation :: Vector3 -> PlayerInfo -> PlayerInfo
setPlayerLocation x p = p{plentity = setEntityLocation (plentity p) x}

setPlayerVelocity :: Vector3 -> PlayerInfo -> PlayerInfo
setPlayerVelocity v p = p{plentity = setEntityVelocity (plentity p) v}

setPlayerAcceleration :: Vector3 -> PlayerInfo -> PlayerInfo
setPlayerAcceleration a p = p{plentity = setEntityAcceleration (plentity p) a}

getUpdateType :: String -> UpdateType
getUpdateType s = case ut of
                    0 -> UpdateLocation
                    1 -> UpdateVelocity
                    _ -> UpdateAcceleration
    where ut = (read . head . tail . words) s

getUpdateCoordinates :: String -> Vector3
getUpdateCoordinates s = (x, y, z)
    where x = read $ (words s) !! 2
          y = read $ (words s) !! 3
          z = read $ (words s) !! 4
